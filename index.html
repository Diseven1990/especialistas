<!DOCTYPE html>
<html lang="pt-PT">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MasterClass • Editor (alinhamento dinâmico por orientação)</title>
<link href="https://fonts.googleapis.com/css2?family=Barlow:wght@800&family=Work+Sans:wght@300;400&display=swap" rel="stylesheet">
<style>
  html,body{margin:0;background:#0f0f0f;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Work Sans',sans-serif}
  .app{display:grid;grid-template-columns:1fr 430px;gap:20px;max-width:min(1680px,96vw);margin:20px auto}
  .stage{background:#1a1a1a;border-radius:14px;padding:12px;display:flex;align-items:center;justify-content:center}
  canvas{width:100%;height:auto;background:transparent;border-radius:10px}
  .panel{background:#141414;border:1px solid #2a2a2a;border-radius:14px;padding:14px;display:flex;flex-direction:column;gap:12px}
  .row{display:flex;flex-direction:column;gap:6px}
  label{font-size:13px;color:#bbb}
  input[type="text"], textarea{background:#0f0f0f;border:1px solid #333;border-radius:10px;color:#f2f2f2;padding:10px 12px;font-size:14px}
  textarea{min-height:80px;resize:vertical;white-space:pre-wrap}
  input[type="range"]{width:100%}
  select, input[type="color"]{background:#0f0f0f;border:1px solid #333;border-radius:10px;color:#f2f2f2;padding:8px 10px}
  button{background:#ff6f4f;border:0;color:#fff;padding:10px 14px;border-radius:10px;font-weight:700;cursor:pointer}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .muted{color:#99a}
</style>
</head>
<body>
  <div class="app">
    <div class="stage">
      <canvas id="c" width="1434" height="700" aria-label="pré‑visualização"></canvas>
    </div>
    <div class="panel">
      <div class="row">
        <label>Layout</label>
        <div class="grid2">
          <input id="bgColor" type="color" value="#f37759" />
          <select id="orientation">
            <option value="right" selected>Fotografia à direita (pílula arredondada à direita)</option>
            <option value="left">Fotografia à esquerda (pílula arredondada à esquerda)</option>
          </select>
        </div>
        <div class="grid2">
          <select id="mcPos">
            <option value="left">“MasterClass” canto superior esquerdo</option>
            <option value="right">“MasterClass” canto superior direito</option>
          </select>
          <span class="muted"></span>
        </div>
        <span class="muted">Sem PNG: a forma é desenhada automaticamente. “MasterClass” a branco.</span>
      </div>

      <div class="row">
        <label>Fotografia do especialista</label>
        <input id="photo" type="file" accept="image/*" />
        <div class="grid2">
          <div class="row"><label>Escala da foto</label><input id="scale" type="range" min="0.2" max="3" step="0.01" value="1" /></div>
          <div class="row"><label>Posição X</label><input id="posX" type="range" min="-1500" max="1500" step="1" value="0" /></div>
          <div class="row"><label>Posição Y</label><input id="posY" type="range" min="-1500" max="1500" step="1" value="0" /></div>
        </div>
      </div>

      <div class="row">
        <label>Círculo da foto (CX/CY/R)</label>
        <div class="grid2">
          <div class="row"><label>CX</label><input id="cx" type="range" min="0" max="2000" step="1" value="1060" /></div>
          <div class="row"><label>CY</label><input id="cy" type="range" min="0" max="1200" step="1" value="350" /></div>
          <div class="row"><label>R</label><input id="cr" type="range" min="10" max="1200" step="1" value="300" /></div>
        </div>
      </div>

      <div class="row">
        <label>Nome (linha 1)</label>
        <input id="nome" type="text" value="NAIARA" />
      </div>
      <div class="row">
        <label>Sobrenome (linha 2)</label>
        <input id="sobrenome" type="text" value="BACK" />
      </div>
      <div class="grid2">
        <div class="row"><label>Título X</label><input id="titleX" type="range" min="0" max="2000" step="1" value="110" /></div>
        <div class="row"><label>Título Y (topo da 1.ª linha)</label><input id="titleY" type="range" min="0" max="1200" step="1" value="310" /></div>
      </div>

      <div class="row">
        <label>Bio (ENTER = nova linha)</label>
        <textarea id="bio">Formada em Publicidade e Propaganda, com MBA em Marketing Digital e Mestrado em Ciências da Comunicação.</textarea>
      </div>
      <div class="grid2">
        <div class="row"><label>Bio X</label><input id="bioX" type="range" min="0" max="2000" step="1" value="110" /></div>
        <div class="row"><label>Bio Y</label><input id="bioY" type="range" min="0" max="2000" step="1" value="560" /></div>
      </div>

      <div class="row">
        <button id="export">Exportar imagem</button>
        <span id="status" class="muted"></span>
      </div>
    </div>
  </div>

<script>
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const bgColor = document.getElementById('bgColor');
  const orientationSel = document.getElementById('orientation');
  const mcPos   = document.getElementById('mcPos');

  const photoInput = document.getElementById('photo');
  const scaleInput = document.getElementById('scale');
  const posXInput  = document.getElementById('posX');
  const posYInput  = document.getElementById('posY');

  const cxInput = document.getElementById('cx');
  const cyInput = document.getElementById('cy');
  const crInput = document.getElementById('cr');

  const nomeInput = document.getElementById('nome');
  const sobrenomeInput = document.getElementById('sobrenome');
  const titleXInput = document.getElementById('titleX');
  const titleYInput = document.getElementById('titleY');

  const bioInput = document.getElementById('bio');
  const bioXInput = document.getElementById('bioX');
  const bioYInput = document.getElementById('bioY');

  const exportBtn = document.getElementById('export');
  const statusEl  = document.getElementById('status');

  const pt = v => v * (96/72);
  function recomputeType(){
    const s = canvas.height / 700;
    NAME_PX = pt(208.11) * s;
    TRACK   = pt(6) * s;
    BIO_PX  = pt(20.8) * s;
    BIO_LH  = Math.round(BIO_PX * 1.45);
  }
  let NAME_PX = pt(208.11), TRACK = pt(6), BIO_PX = pt(20.8), BIO_LH = Math.round(pt(20.8)*1.45);
  recomputeType();

  let photo = null, photoURL = null;

  function drawPill(color, side){
    const W = canvas.width, H = canvas.height;
    const R = H/2;
    ctx.save();
    ctx.clearRect(0,0,W,H);
    ctx.beginPath();
    if(side === 'right'){
      ctx.moveTo(0,0);
      ctx.lineTo(W-R,0);
      ctx.arc(W-R, R, R, -Math.PI/2, Math.PI/2, false);
      ctx.lineTo(0,H);
    } else {
      ctx.moveTo(R,0);
      ctx.lineTo(W,0);
      ctx.lineTo(W,H);
      ctx.lineTo(R,H);
      ctx.arc(R, R, R, Math.PI/2, -Math.PI/2, false);
    }
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
    ctx.restore();
  }
  function drawMasterClass(){
    const W = canvas.width;
    ctx.save();
    ctx.fillStyle = '#fff';
    ctx.font = `800 ${Math.round(52 * (canvas.height/700))}px 'Barlow', sans-serif`;
    ctx.textBaseline = 'top';
    const pad = Math.round(48 * (canvas.height/700));
    const text = "MasterClass";
    const m = ctx.measureText(text);
    if(mcPos.value === 'right'){
      ctx.fillText(text, W - pad - m.width, pad);
    }else{
      ctx.fillText(text, pad, pad);
    }
    ctx.restore();
  }
  function drawTracked(text, x, y, sizePx, trackingPx){
    ctx.font = `800 ${sizePx}px 'Barlow', sans-serif`;
    ctx.fillStyle = '#fff'; ctx.textBaseline = 'alphabetic';
    let cursor = x;
    for(const ch of (text||'')){
      const m = ctx.measureText(ch);
      ctx.fillText(ch, cursor, y);
      cursor += m.width + trackingPx;
    }
  }
  function trackedWidth(text, sizePx, trackingPx){
    ctx.font = `800 ${sizePx}px 'Barlow', sans-serif`;
    let w=0; for(const ch of (text||'')){ w += ctx.measureText(ch).width + trackingPx; } return w;
  }
  function wrapLeft(text, x, y, maxW, lh){
    ctx.font = `300 ${BIO_PX}px 'Work Sans', sans-serif`;
    ctx.fillStyle = '#fff'; ctx.textBaseline = 'top';
    const paras = String(text||'').split('\n');
    for(const p of paras){
      const words = p.split(' '); let line='';
      for(let i=0;i<words.length;i++){
        const tl = line + words[i] + ' ';
        if(ctx.measureText(tl).width > maxW && i>0){ ctx.fillText(line,x,y); line=words[i]+' '; y+=lh; }
        else { line = tl; }
      }
      ctx.fillText(line, x, y); y += lh;
    }
  }
  function wrapRight(text, rightEdge, y, maxW, lh){
    // desenha alinhado à direita (x dinâmico por linha)
    ctx.font = `300 ${BIO_PX}px 'Work Sans', sans-serif`;
    ctx.fillStyle = '#fff'; ctx.textBaseline = 'top';
    const paras = String(text||'').split('\n');
    for(const p of paras){
      const words = p.split(' '); let line=''; let lines=[];
      for(let i=0;i<words.length;i++){
        const tl = line + words[i] + ' ';
        if(ctx.measureText(tl).width > maxW && i>0){ lines.push(line); line=words[i]+' '; }
        else { line = tl; }
      }
      lines.push(line);
      for(const L of lines){
        const w = ctx.measureText(L).width;
        ctx.fillText(L, rightEdge - w, y);
        y += lh;
      }
    }
  }

  function margin(){ return Math.round(30 * (canvas.height/700)); }

  function textMaxWidth(){
    const side = orientationSel.value;
    const cx = +cxInput.value, r = +crInput.value;
    const m = margin();
    if(side === 'right'){
      return Math.max(200, (cx - r) - m - +titleXInput.value);
    } else {
      // quando à esquerda, a largura útil é da âncora até ao fim da pílula (canvas.width - m)
      return Math.max(200, (canvas.width - m) - +titleXInput.value);
    }
  }

  function bioMetrics(){
    const side = orientationSel.value;
    const cx = +cxInput.value, r = +crInput.value;
    const m = margin();
    if(side === 'right'){
      return {maxW: Math.max(200, (cx - r) - m - +bioXInput.value), startX: +bioXInput.value, rightEdge: null};
    } else {
      // alinhado à direita: direita da área = canvas.width - m
      const rightEdge = canvas.width - m;
      const maxW = Math.max(200, rightEdge - +bioXInput.value);
      return {maxW, startX: null, rightEdge};
    }
  }

  function applyOrientationDefaults(){
    const side = orientationSel.value;
    const W = canvas.width, H = canvas.height, R = H/2;
    if(side === 'right'){
      cxInput.value = Math.round(W - R*0.7);
      cyInput.value = Math.round(H*0.5);
      crInput.value = Math.round(H*0.43);
      titleXInput.value = Math.round(110 * (H/700));
      titleYInput.value = Math.round(310 * (H/700));
      bioXInput.value = titleXInput.value;
      bioYInput.value = Math.round(560 * (H/700));
      mcPos.value = 'left';
    } else {
      cxInput.value = Math.round(R*0.7);
      cyInput.value = Math.round(H*0.5);
      crInput.value = Math.round(H*0.43);
      titleXInput.value = Math.round(R + 60);
      titleYInput.value = Math.round(310 * (H/700));
      bioXInput.value = Math.round(R + 60);
      bioYInput.value = Math.round(560 * (H/700));
      mcPos.value = 'right';
    }
  }

  function render(){
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);
    const side = orientationSel.value;

    // 1) Forma base + MasterClass
    drawPill(bgColor.value, side);
    drawMasterClass();

    // 2) Foto recortada
    if(photo){
      const cx=+cxInput.value, cy=+cyInput.value, r=+crInput.value;
      const scale = +scaleInput.value, dx=+posXInput.value, dy=+posYInput.value;
      ctx.save(); ctx.beginPath(); ctx.arc(cx,cy,r-1,0,Math.PI*2); ctx.clip();
      const pw=photo.naturalWidth, ph=photo.naturalHeight;
      const base = Math.max((2*r)/pw,(2*r)/ph) * scale;
      const w=pw*base, h=ph*base;
      ctx.drawImage(photo, cx - w/2 + dx, cy - h/2 + dy, w, h);
      ctx.restore();
    }

    // 3) Título (duas linhas): esquerda = normal; esquerda arredondada = alinhar à direita
    let size = NAME_PX, track = TRACK;
    const nome = (nomeInput.value||'').toUpperCase();
    const maxW = textMaxWidth();
    while (trackedWidth(nome, size, track) > maxW && size > 40){
      size -= 1; track = TRACK * (size/NAME_PX);
    }
    const topY = +titleYInput.value;
    if(side === 'right'){
      const startX = +titleXInput.value;
      drawTracked(nome, startX, topY, size, track);
      drawTracked((sobrenomeInput.value||'').toUpperCase(), startX, topY + size*1.08, size, track);
    } else {
      // alinhar à direita
      const rightEdge = canvas.width - margin();
      const w1 = trackedWidth(nome, size, track);
      const w2 = trackedWidth((sobrenomeInput.value||'').toUpperCase(), size, track);
      drawTracked(nome, rightEdge - w1, topY, size, track);
      drawTracked((sobrenomeInput.value||'').toUpperCase(), rightEdge - w2, topY + size*1.08, size, track);
    }

    // 4) Bio com alinhamento dependente
    const bm = bioMetrics();
    if(side === 'right'){
      wrapLeft(bioInput.value, bm.startX, +bioYInput.value, bm.maxW, BIO_LH);
    } else {
      wrapRight(bioInput.value, bm.rightEdge, +bioYInput.value, bm.maxW, BIO_LH);
    }

    statusEl.textContent = `${W}×${H} • orientação: ${side}`;
  }

  photoInput.addEventListener('change', e=>{
    const f=e.target.files?.[0]; if(!f) return;
    if(photoURL) URL.revokeObjectURL(photoURL);
    photoURL = URL.createObjectURL(f);
    const img=new Image(); img.onload=()=>{ photo=img; render(); }; img.src=photoURL;
  });

  [bgColor, orientationSel, mcPos, scaleInput, posXInput, posYInput, cxInput, cyInput, crInput,
   nomeInput, sobrenomeInput, titleXInput, titleYInput, bioInput, bioXInput, bioYInput]
   .forEach(el=>el.addEventListener('input', render));

  orientationSel.addEventListener('change', ()=>{ applyOrientationDefaults(); render(); });

  document.getElementById('export').addEventListener('click', ()=>{
    const a=document.createElement('a');
    const file=`masterclass_${(nomeInput.value+'_'+sobrenomeInput.value).toLowerCase().replace(/[^a-z0-9]+/g,'_')}.png`;
    if(canvas.toBlob){
      canvas.toBlob(b=>{ const url=URL.createObjectURL(b); a.href=url; a.download=file; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1000); }, 'image/png');
    } else { a.href=canvas.toDataURL('image/png'); a.download=file; a.click(); }
  });

  applyOrientationDefaults();
  render();
</script>
</body>
</html>
